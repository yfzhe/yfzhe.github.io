<?xml version="1.0" encoding="utf-8"?> 
<rss version="2.0">
 <channel>
  <title>看看就好的博客: Posts tagged 'programming'</title>
  <description>看看就好的博客: Posts tagged 'programming'</description>
  <link>https://yfzhe.github.io/tags/programming.html</link>
  <lastBuildDate>Tue, 11 Jan 2022 21:04:24 UT</lastBuildDate>
  <pubDate>Tue, 11 Jan 2022 21:04:24 UT</pubDate>
  <ttl>1800</ttl>
  <item>
   <title>译后记</title>
   <link>https://yfzhe.github.io/posts/2022/01/afterword/?utm_source=programming&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:https-yfzhe-github-io:-posts-2022-01-afterword</guid>
   <pubDate>Tue, 11 Jan 2022 21:04:24 UT</pubDate>
   <author>yfzhe</author>
   <description>
&lt;p&gt;其实也不算什么译后记。在翻译完&lt;a href="https://yfzhe.github.io/posts/2022/01/a-closure-is-poor-man-s-object-and-vice-versa/"&gt;前面一篇文章&lt;/a&gt;之后，没更多想说的了。 毕竟译文前面也写了很长一段，能憋出来的都写在里面了。开这一篇文章其实是因为前面 准备这篇译文的时候，把整个讨论串的消息都读了一遍，感觉其中有不少精彩的观点和论述， 摘录出来放到这里。&lt;/p&gt;

&lt;p&gt;翻译太难，这里就直接放原文，不翻译了。斜体和粗体均为编者所加。和之前一样， 每段后面附上原文链接。后面的中文部分是我的一些想法。&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="关于抽象层次"&gt;关于抽象层次&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;m not suggesting that Scheme relies on fewer lines of code than C, but rather that it doesn&amp;rsquo;t really matter in either case. There are numerous abstraction layers at work here from the hardware (memory, cache layers, processor, etc.) through the OS and standard user-level library components up to the individual applications. &lt;em&gt;The beauty of abstraction layers is that when they work right you can ignore everything below the current layer.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;By Russ Ross, &lt;a href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03300.html"&gt;http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03300.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;有时候会看到一些人说，你用的这个环境/语言/平台把底层都封装起来了，程序员对 一些基本的事情都不了解，或者是没法做一些我想要的操作，这是个错误。但计算机科学 本身就是一层层抽象叠起来的。可能更重要的事情是先弄清楚你要在哪一个抽象层次上 操作，然后再做事情。&lt;/p&gt;

&lt;h1 id="关于语言和性能"&gt;关于语言和性能&lt;/h1&gt;

&lt;p&gt;The fastest language of any of these ought to be hand-coded assembler - why aren&amp;rsquo;t all the performance-sensitive folk using that? C and C++ occupy a very similar role today that assembler once did. As actual deployed language and compiler technology has improved, there&amp;rsquo;s less and less reason to write substantial amounts of code in a language that&amp;rsquo;s designed to mirror the architecture of a CPU. The strongest justification you can give today for C is that it&amp;rsquo;s portable and highly-tuned across multiple architectures, i.e. the legacy argument. That one, I&amp;rsquo;ll grant you.&lt;/p&gt;

&lt;p&gt;By Anton van Straaten, &lt;a href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03298.html"&gt;http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03298.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不多说了。&lt;/p&gt;

&lt;h1 id="关于-lazy-evaluation"&gt;关于 lazy evaluation&lt;/h1&gt;

&lt;p&gt;As for whether Haskell fans consider laziness crucial to a functional language, you might be surprised to find that not all of them do. In particular, &lt;em&gt;Simon Peyton Jones doesn&amp;rsquo;t seem to find laziness essential&lt;/em&gt; (see &lt;a href="http://www.research.microsoft.com/~simonpj/papers/haskell-retrospective/index.htm"&gt;http://www.research.microsoft.com/~simonpj/papers/haskell-retrospective/index.htm&lt;/a&gt;). What he thinks IS essential, as I&amp;rsquo;ve said, is being &amp;ldquo;purely functional,&amp;rdquo; and he argues that the biggest benefit of sticking to laziness was that it forced them to stick to their pure functional guns, even when the going was very tough.&lt;/p&gt;

&lt;p&gt;By Matt Hellige, &lt;a href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03232.html"&gt;http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03232.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于很多 Haskell 人来说，lazy evaluation 都是他们心中函数式编程必要特性的集合中 必须的一个。再考虑到 Haskell 在函数式编程社区里 cult 般的地位，你会看到不少不用 Haskell 的人也认为 lazy evalution 是 fp 所必要的特性（去知乎上就能看到很多）。 但这里告诉我们，Haskell 的创造者（之一）也认为 laziness 并不是函数式编程所必须的。&lt;/p&gt;

&lt;h1 id="关于-side-effects"&gt;关于 side effects&lt;/h1&gt;

&lt;p&gt;&amp;gt; isn&amp;rsquo;t functional programming just programming without side effects&lt;/p&gt;

&lt;p&gt;You can classify functional languages as pure/impure, lazy/eager. You tend to find that the lazy languages (Haskell, Clean, Miranda) are pure, and impure languages (Lisp, Scheme, ML) are eager. &lt;em&gt;There&amp;rsquo;s no reason you can&amp;rsquo;t have a pure eager language, but I can&amp;rsquo;t think of one (anybody?).&lt;/em&gt; Impure lazy languages aren&amp;rsquo;t really feasible, because the laziness means that you can&amp;rsquo;t predict when side-effects will occur, which is not useful if you use side-effects to perform I/O.&lt;/p&gt;

&lt;p&gt;By &amp;ldquo;Bayley, Alistair&amp;rdquo;, &lt;a href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03219.html"&gt;http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03219.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;十几年前（也快二十年了），pure eager language 还是理论上存在但现实中没有的东西。 但随着 algebraic effect 如火如荼的发展，现在能举出好几个这样的语言了。&lt;/p&gt;

&lt;h2 id="关于-first-class-functions"&gt;关于 first-class functions&lt;/h2&gt;

&lt;p&gt;&amp;gt; Functional programming is a style, typified by the use of first-class functions, and higher-order functions (functions that take functions as arguments and apply them, and functions that return functions).&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s another reason that higher-order functions tend to go hand-in-hand with functional languages, and it&amp;rsquo;s a paradigmatic one. Since functional languages are generally founded on the idea that &amp;ldquo;everything is a function,&amp;rdquo; we&amp;rsquo;d like them to be able to realize this model. &lt;em&gt;The locus classicus for this idea is, of course, lambda calculus, in which one may model any traditional computing construct using only functions, from the Church numerals on up.&lt;/em&gt; Naturally, all these functions are higher-order and anonymous. So the natural translation of lambda-calculus ideas to a practical language BEGINS with higher-order anonymous functions, rather than ending there. It is, in fact, the introduction of non-lambda binding constructs and non-functional primitive data that is, in some sense, a perversion&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This is not so different from the object-oriented idea that everything is be an object, or the older &amp;ldquo;von Neumann idea&amp;rdquo; that everything is a mutable cell.&lt;/em&gt; It&amp;rsquo;s just that in order for everything to be a function, some of those functions need to be higher-order.&lt;/p&gt;

&lt;p&gt;By Matt Hellige, &lt;a href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03236.html"&gt;http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03236.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我自己从来没能回到 lambda calculus 这个本源来考虑 first-class functions 的问题。 是的，在 lambda calculus 里，所有的值都是用函数来表示的，true 和 false 是这样， 自然数也是借由 Church encoding 通过 lambda 表示出来。上面的这个视角很有意思。&lt;/p&gt;

&lt;h1 id="关于用-scheme-来实现语言"&gt;关于用 Scheme 来实现语言&lt;/h1&gt;

&lt;p&gt;Describing it as &amp;ldquo;a book about how to implement a Scheme in Scheme&amp;rdquo; rather misses the point. One point being missed is the importance (or lack thereof) of typical language syntaxes. &lt;em&gt;Think of Scheme for this purpose as a simple and consistent way of representing abstract syntax trees for any language.&lt;/em&gt; That&amp;rsquo;s why it has little obvious &amp;ldquo;syntax&amp;rdquo; other than parentheses, and how you can do things like express XML natively in Scheme (see e.g. SXML).&lt;/p&gt;

&lt;p&gt;When you see a snippet of code in EOPL that&amp;rsquo;s written in one of the book&amp;rsquo;s own languages, don&amp;rsquo;t think of it as Scheme - think of it as the essential semantic core of a language which could have any of a variety of surface syntaxes. The EOPL languages already have some syntax, provided by macros, but this also can be thought of as a kind of core/internal syntax. &lt;em&gt;You could take any of the EOPL languages and use a lexer and parser generator to quite easily create a more traditional syntactic surface, which maps to the exact code in the EOPL book.&lt;/em&gt; What you&amp;rsquo;d end up with would look as much like any traditional language as you want it to (although your semantic core would be better designed). So for the purposes of EOPL, C/C++ and a language&amp;rsquo;s surface syntax are both distractions.&lt;/p&gt;

&lt;p&gt;What I&amp;rsquo;m describing might sound impractical to the uninitiated - maybe you wouldn&amp;rsquo;t want to implement a &amp;ldquo;real&amp;rdquo; language on top of a Scheme-like core. The only problem with this assumption is it&amp;rsquo;s completely wrong: there are any number of real languages that do exactly this. &lt;em&gt;Every functional language that can be compiled to a bytecode, including Haskell and various ML varieties, compiles to a bytecode that bears a strong resemblance to Scheme.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Why is that? It&amp;rsquo;s because &lt;em&gt;Scheme is an expression of some core mathematical ideas about computation: &lt;strong&gt;a relatively minimal set of features that provides a complete computational framework&lt;/strong&gt;.&lt;/em&gt; If you&amp;rsquo;re implementing a functional language, when you get down to its core, below the syntax and the derived semantic features, you&amp;rsquo;re likely to end up with something that looks a heck of a lot like a Scheme core.&lt;/p&gt;

&lt;p&gt;By Anton van Straaten, &lt;a href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03292.html"&gt;http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03292.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;用 S-expression 来做 AST，以尽量少的功能同时尽量少的限制来提供丰富的表达能力， 这是 Scheme 的两个财富。上面加粗的句子，在 rnrs 里也可以找到同样的精神：&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary.&lt;/p&gt;&lt;/blockquote&gt;

&lt;h1 id="one-more-thing"&gt;One more thing&amp;hellip;&lt;/h1&gt;

&lt;p&gt;前面说不知道怎么翻译 &amp;ldquo;poor man&amp;rdquo;，&lt;a href="https://citreu.gitlab.io"&gt;@Zhu Aisi&lt;/a&gt; 说可以这么翻译：&lt;/p&gt;

&lt;div class="text-center"&gt;闭包是消费降级的对象，对象是消费降级的闭包&lt;/div&gt;

&lt;p&gt;可以说是一个颇具时代精神的译法了，特意记在这里。&lt;/p&gt;</description></item>
  <item>
   <title>译："A closure is poor man's object, an object is poor man's closure."</title>
   <link>https://yfzhe.github.io/posts/2022/01/a-closure-is-poor-man-s-object-and-vice-versa/?utm_source=programming&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:https-yfzhe-github-io:-posts-2022-01-a-closure-is-poor-man-s-object-and-vice-versa</guid>
   <pubDate>Sat, 08 Jan 2022 21:52:38 UT</pubDate>
   <author>yfzhe</author>
   <description>
&lt;p&gt;编程范式的讨论，应该算是程序员社区的日常话题。函数式编程和面向对象，分别是什么， 孰优孰劣，总是争论不休，如同无休无止的宗教战争。而 closure 和 object，可以称作是 fp 和 oop 各自的代表概念。&lt;/p&gt;

&lt;p&gt;要翻译的这篇文章，写于 2003 年，是一条邮件列表里的消息。它出自一个 &lt;a href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/threads.html#03215"&gt;很长的讨论串&lt;/a&gt;， 始作俑者&lt;sup&gt;&lt;a href="#2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-1-definition" name="2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt;标题 &amp;ldquo;What&amp;rsquo;s so cool about Scheme?&amp;rdquo;，似乎不容易联系到这里。 最后一段留下了一个问题：&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Is Scheme really a &amp;lsquo;functional programming language&amp;rsquo; or is it just a really general purpose tool that allows functional programming?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Scheme 真的是一门“函数式编程”语言吗？然后就引发了长长的讨论，讨论什么是函数式编程， 函数式编程必要的特性有哪些，什么是 Scheme / Lisp 的特质。当然，不可避免地， 会提到其他编程范式，当然，主要是面向对象。&lt;/p&gt;

&lt;p&gt;然后就到了这篇文章，&lt;a href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html"&gt;http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html&lt;/a&gt;。 它先从倾向闭包的角度，后从倾向对象的角度，来阐发一者无非是低劣版本的另一者。 但是当两种针锋相对的态度出现在同一篇文章中，仿佛太极阴阳，两相融合。因为这种 平等宽容的态度，我很喜欢这个文章。另一个我喜欢的点是在于文章最后编的禅宗公案， 有棒喝，有机锋；给原本朴实的技术讨论增加了不少禅意。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;A closure is poor man&amp;rsquo;s object, an object is poor man&amp;rsquo;s closure.&amp;rdquo; 从文章中提取 出来的这个句子，成为了编程语言社区里的一条名言或是警句；也被用作这篇文章的标题。&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;按理这个句子，特别是作为文章的标题，也应该翻译出来；但是我在 “poor man” 一词 该如何翻译上犯了难。其他地方多是译为“穷人”，但是我更想译为“可怜人”。于是标题译为：&lt;/p&gt;

&lt;h1 class="text-center"&gt;闭包是可怜人的对象，对象是可怜人的闭包&lt;/h1&gt;

&lt;p&gt;另外，原文开头是几层的引用回复，这里为了便于阅读理解，也为了排版方便， 把几段引文拆出来，按先后顺序线性排开，同时在每段后面增加了原文的出处的链接。 前面三个部分是被拆出的引文，最后一个部分才是文章的主要部分。&lt;/p&gt;

&lt;p&gt;以下是译文：&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id="anton-van-straaten-于-20030603-202357-0400"&gt;Anton van Straaten 于 2003&amp;ndash;06&amp;ndash;03 20:23:57 &amp;ndash;0400：&lt;/h2&gt;

&lt;p&gt;我部分同意你的观点；但真的，如果没有闭包，人们就会用——也确实在用—— 种种不优雅的怪异的方法&lt;sup&gt;&lt;a href="#2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-2-definition" name="2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-2-return"&gt;2&lt;/a&gt;&lt;/sup&gt;——就比如，对象 ;o)&lt;/p&gt;

&lt;p&gt;&lt;a href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03257.html"&gt;http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03257.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id="mike-newhall-于-20030603-203614-0400"&gt;Mike Newhall 于 2003&amp;ndash;06&amp;ndash;03 20:36:14 &amp;ndash;0400：&lt;/h2&gt;

&lt;p&gt;另外，虽然我不记得原话，Christian Queinnec 在 &lt;em&gt;LISP In Small Pieces&lt;/em&gt; 里指出， 尽管很多人认为对象是「可怜人的闭包」，但（在他看来）闭包实际就是可怜人的对象。&lt;/p&gt;

&lt;p&gt;&lt;a href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03258.html"&gt;http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03258.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id="guy-steele-于-20030604-105409-0400"&gt;Guy Steele 于 2003&amp;ndash;06&amp;ndash;04 10:54:09 &amp;ndash;0400：&lt;/h2&gt;

&lt;p&gt;闭包是一个对象，它有且仅有一个方法 (method)：「应用 (apply)」。&lt;/p&gt;

&lt;p&gt;&lt;a href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03269.html"&gt;http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03269.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id="anton-van-straaten-于-20030604-131321-0400"&gt;Anton van Straaten 于 2003&amp;ndash;06&amp;ndash;04 13:13:21 &amp;ndash;0400：&lt;/h2&gt;

&lt;p&gt;从一个角度来看，这是对的；我也是这么看待对象被用来解决缺少闭包的问题的。 闭包的简洁可以成为一种财富：类和接口会阻碍行为的简单参数化 (simple parameterization of behavior)。任何在 Java 或 C++ 里尝试函数式编程的人 都会碰到这一点——能够实现，但是太冗长乏味。如果你想做的不过是像  &lt;code&gt;(map somefun mylist)&lt;/code&gt; 这样的事情，那么能够简洁地定义可执行的「对象」（闭包）， 有必要的时候甚至可以将它们内联 (inline)，这会非常有用。&lt;/p&gt;

&lt;p&gt;但从另一个角度看，闭包的这个应用「方法」可以用作底层 (low-level) 的方法分派 (method dispatch) 机制，所以闭包可以被用来，且正在被用来实现有效的、具有多个 方法的对象系统。Oleg Kiselyov 有一篇关于这个主题的短文： &lt;a href="http://okmij.org/ftp/Scheme/oop-in-fp.txt"&gt;http://okmij.org/ftp/Scheme/oop-in-fp.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以这种方式使用闭包，可以说闭包比对象强大，因为它可以支持更多的功能，而不是仅仅 作为语言提供的一个方法分派机制。将闭包视作用以实现对象的构造单元，那么显而易见， 对象是可怜人的闭包。&lt;/p&gt;

&lt;p&gt;但是，Smalltalk&lt;sup&gt;&lt;a href="#2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-3-definition" name="2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-3-return"&gt;3&lt;/a&gt;&lt;/sup&gt; 用户可能会说，等等，如果你要费尽心思在你的语言里实现闭包 这样的东西，既然这闭包已经很像对象了，为什么不一路走下去，去实现「真正」的、支持 任意数量个方法的对象呢？这时闭包不过是对象的一种特例。如果你的语言里只有这些受限 的闭包，而你却又不得不在此之上实现一个对象系统，那么显而易见，闭包是可怜人的对象。&lt;/p&gt;

&lt;p&gt;考虑到这两种观点的对立，我认为闭包还是对象的问题应该成为一个公案。我会去拿到禅法 认证&lt;sup&gt;&lt;a href="#2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-4-definition" name="2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-4-return"&gt;4&lt;/a&gt;&lt;/sup&gt;，将 Norman Adams（「对象是可怜人的闭包」据说是他提出的）和 Christian Queinnec（「闭包是可怜人的对象」）结合成一个名为 Qc Na 的大禅师。我还会不谦虚 地把自己以一个学生的形象放到这则故事里，正如我在这条消息的最后一段里提过的： &lt;a href="http://www.ai.mit.edu/~gregs/ll1-discuss-archive-html/msg01488.html"&gt;http://www.ai.mit.edu/~gregs/ll1-discuss-archive-html/msg01488.html&lt;/a&gt;&amp;hellip;&lt;sup&gt;&lt;a href="#2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-5-definition" name="2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-5-return"&gt;5&lt;/a&gt;&lt;/sup&gt; 我确信我从思考这两种看似对立的角度中获得了一些启迪。下面是这则公案：&lt;/p&gt;

&lt;div class="text-center"&gt;* * *&lt;/div&gt;

&lt;p&gt;德高望重的 Qc Na 法师正和弟子 Anton 散步。想和师父讨论问题，Anton 打开了话茬， 「师父，我听说对象是个很好的东西，这是真的吗？」Qc Na 法师眼含怜悯看着学生，回答道： 「傻孩子，对象不过是可怜人的闭包罢了。」&lt;/p&gt;

&lt;p&gt;收到训斥，Anton 离开师父回到自己的小房间，决心研究闭包。他仔细阅读 “Lambda: The Ultimate&amp;hellip;”&lt;sup&gt;&lt;a href="#2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-6-definition" name="2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-6-return"&gt;6&lt;/a&gt;&lt;/sup&gt; 系列的全部论文还有其他相关的论文；又用一个基于闭包的对象系统 实现了一个小的 Scheme 解释器。他收获颇丰，期待向师父汇报自己的进展。&lt;/p&gt;

&lt;p&gt;再一次和 Qc Na 法师散步时，Anton 试图让老师惊讶：「师父，我已经认真学习了这个问题， 现在我明白了，对象确实是可怜人的闭包。」听罢，Qc Na 大师对 Anton 当头一棒，「你何 时才能学会？闭包是可怜人的对象。」当是时，Anton 开悟。&lt;/p&gt;

&lt;p&gt;:)&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;指这个讨论串的第一条消息。&amp;nbsp;&lt;a href="#2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-2-definition" class="footnote-definition"&gt;
   &lt;p&gt;原文为 &amp;ldquo;use all sorts of hacks anyway&amp;rdquo;，这个 &amp;ldquo;hack&amp;rdquo; 实在难译。&amp;nbsp;&lt;a href="#2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-2-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-3-definition" class="footnote-definition"&gt;
   &lt;p&gt;一个经典的程序语言，最早的面向对象语言之一。强调消息传递（而不是方法调用）。  Alan Key 领衔设计。参见 Wikipedia：&lt;a href="https://en.wikipedia.org/wiki/Smalltalk"&gt;https://en.wikipedia.org/wiki/Smalltalk&lt;/a&gt;。&amp;nbsp;&lt;a href="#2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-3-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-4-definition" class="footnote-definition"&gt;
   &lt;p&gt;原文为 &amp;ldquo;I&amp;rsquo;ll take some koanic license&amp;rdquo;。&amp;nbsp;&lt;a href="#2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-4-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-5-definition" class="footnote-definition"&gt;
   &lt;p&gt;原文如此，这个链接现已失效，一个现在可访问的链接为  &lt;a href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg01488.html"&gt;http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg01488.html&lt;/a&gt;&amp;nbsp;&lt;a href="#2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-5-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
  &lt;li id="2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-6-definition" class="footnote-definition"&gt;
   &lt;p&gt;由 Guy L. Steele 和 Gerald Jay Sussman 完成的一系列论文（前者也在本文中出现），  提出了 Scheme 和整个函数式编程领域中诸多重要概念和技术。"Lambda the ultimate"  本身也成为函数式编程社区里的一个标语。&amp;nbsp;&lt;a href="#2022-01-08-a-closure-is-poor-man-s-object-and-vice-versa-footnote-6-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description></item></channel></rss>